{package parser}

Input <- __ v1:(Object / Field*) EOF { return toInput(v1, c) }

Object <- v1:LBRACE v2:Field* v3:RBRACE { return toObject(v1, v2, v3, c) }

Field <- IfField / ForField / LetField / FieldField / KeyField / EmbeddedField

EmbeddedField <- v1:Expression v2:COMMA? { return toEmbeddedField(v1, v2, c) }

LetField <- v1:LET v2:Identifier v3:(ASSIGN/COLON) v4:Expression v5:COMMA? { return toLetField(v1, v2, v3, v4, v5, c) }

IfField <- v1:IfExpr COMMA? { return noop(v1) }

IfExpr <- IF v1:Expression v2:Object v3:ElseExpr? { return toIfField(v1, v2, v3, c) }

ElseExpr <- ELSE v1:(Object / IfExpr) { return toElse(v1, c) }

KeyField <- v1:Key COLON v2:Expression v3:COMMA? { return toField(v1, v2, v3, c) }

FieldField <- v1:Key COLON v2:(ForField / FieldField / KeyField) v3:COMMA? { return toFieldField(v1, v2, v3, c) }

ForField <- FOR v1:Identifier v2:(COMMA Identifier)? IN v3:Expression v4:Object v5:COMMA? { return toForField(v1, v2, v3, v4, v5, c) }

Key <- v1:(String / Identifier / KeyMatch) { return toKey(v1, c) }

KeyMatch <- LBRACKET REGEQ v1:String v2:RBRACKET { return toKeyMatch(v1, v2, c) }

Value <- Null / Boolean / Number / Array / Object / String

Null <- v1:NULL { return toNull(v1, c) }

Boolean <- v1:(TRUE / FALSE) { return toBool(v1, c) }

String <- TripleString / SingleString

SingleString <- StringStart v1:(!STRINGEND !EOL (Interpolation / Character))* v2:STRINGEND { return toString(v1, v2, c) }
TripleString <- TripleStringStart v1:(!TRIPLESTRINGEND (Interpolation / Character))* v2:TRIPLESTRINGEND { return toString(v1, v2, c) }

Interpolation <- "\\(" v1:Expression ')' { return noop(v1) }

Expression <- v1:Selector v2:(Op Selector)* { return toExpression(v1, v2, c) }

Selector <- v1:NOT? v2:(Parens / ListComprehension / Value / Identifier) v3:(DotLookup/SliceLookup/IndexLookup/Call)* { return toSelector(v1, v2, v3, c) }

ListComprehension <- v1:LBRACKET FOR v2:Identifier v3:(COMMA Identifier)? IN v4:Expression v5:Object v6:(IF Expression)? v7:RBRACKET { return toListComprehension(v1, v2, v3, v4, v5, v6, v7, c) }

Parens <- LPAREN v1:Expression RPAREN { return toParens(v1, c) }

DotLookup <- DOT v1:Identifier { return toDotLookup(v1, c) }
SliceLookup <- LBRACKET v1:Expression COLON v2:Expression RBRACKET { return toSliceLookup(v1, v2, c) }
IndexLookup <- LBRACKET v1:Expression RBRACKET { return toIndexLookup(v1, c) }
Call <- LPAREN v1:PositionalArgs v2:NamedArgs? RPAREN { return toCall(v1, v2, c) }

PositionalArgs <- v1:(!NamedArgs Expression)? v2:(COMMA !NamedArgs Expression)* { return toArray(v1, v2, c) }
NamedArgs <- v1:KeyField+ { return toNamedArgs(v1, c) }

Op <- v1:(MINUS / PLUS / MUL / DIVIDE / AND / OR / MERGE / EQUALS / NOTEQUALS / REGEQ / REGNEQ / LTE / GTE / LT / GT) { return newOp(v1, c) }

Array <- LBRACKET v1:Expression? v2:(COMMA Expression)* COMMA? RBRACKET { return toArray(v1, v2, c) }

Identifier <- v1:IdentStart v2:IdentCont* v3:__ { return identifier(v1, v2, v3, c) }
IdentStart <- [a-zA-Z_]
IdentCont <- IdentStart / Digit

Character <- ('\\' 'u' Hex Hex Hex Hex /
    '\\' [bfnrt'"\\] /
    [\n\r] /
    [\u0020-\u10FFFF]) { return toChar(c) }

Hex <- Digit / [a-fA-F]
Digit <- '0' / OneNine
OneNine <- [1-9]

Number <- Integer Fraction? Exponent? Suffix? __ { return toNumber(c) }
Integer <- OneNine DigitUnderscore+ / Digit / '-' OneNine DigitUnderscore+ / '-' Digit
DigitUnderscore <- '_' / Digit
Fraction <- '.' Digit+
Exponent <- [Ee] Sign? Digit+
Sign <- [-+]
Suffix <- BiSuffix / DecSuffix
BiSuffix <- [KkMmGgTtPpEeZzYy] 'i'
DecSuffix <- [KkMmGgTtPpEeZzYy]

__ <- v1:(Comment / _)* { return toWhitespace(v1, c) }
_ <- v1:(' ' / '\t' / EOL) { return space(c) }
Comment <- "//" v1:(!EOL .)* EOL { return comment(c) }
EOL <- "\r\n" / '\n' / '\r'
StringStart <- '"'
TripleStringStart <- "\"\"\""

// Tokens, these all consume trailing white space
NULL <- v1:"null" v2:__ { return token(v1, v2, c) }
TRUE <- v1:"true" v2:__ { return token(v1, v2, c) }
FALSE <- v1:"false" v2:__ { return token(v1, v2, c) }
LET <- v1:"let" v2:__ { return token(v1, v2, c) }
ASSIGN <- v1:"=" v2:__ { return token(v1, v2, c) }
NOT <- v1:"!" v2:_* { return token(v1, v2, c) }
IF <- v1:"if" v2:_* { return token(v1, v2, c) }
ELSE <- v1:"else" v2:_* { return token(v1, v2, c) }
IN <- v1:"in" v2:_* { return token(v1, v2, c) }
FOR <- v1:"for" v2:_* { return token(v1, v2, c) }
COMMA <- v1:"," v2:_* { return token(v1, v2, c) }
LPAREN <- v1:"(" v2:__ { return token(v1, v2, c) }
RPAREN <- v1:")" v2:__ { return token(v1, v2, c) }
LBRACE <- v1:"{" v2:__ { return token(v1, v2, c) }
RBRACE <- v1:"}" v2:__ { return token(v1, v2, c) }
LBRACKET <- v1:"[" v2:_* { return token(v1, v2, c) }
RBRACKET <- v1:"]" v2:__ { return token(v1, v2, c) }
MINUS <- v1:"-" v2:__ { return token(v1, v2, c) }
MUL <- v1:"*" v2:__ { return token(v1, v2, c) }
PLUS <- v1:"+" v2:__ { return token(v1, v2, c) }
DIVIDE <- v1:"/" v2:__ { return token(v1, v2, c) }
LT <- v1:"<" v2:__ { return token(v1, v2, c) }
LTE <- v1:"<=" v2:__ { return token(v1, v2, c) }
GT <- v1:">" v2:__ { return token(v1, v2, c) }
GTE <- v1:">=" v2:__ { return token(v1, v2, c) }
MERGE <- v1:"&" v2:__ { return token(v1, v2, c) }
EQUALS <- v1:"==" v2:__ { return token(v1, v2, c) }
NOTEQUALS <- v1:"!=" v2:__ { return token(v1, v2, c) }
AND <- v1:"&&" v2:__ { return token(v1, v2, c) }
OR <- v1:"||" v2:__ { return token(v1, v2, c) }
DOT <- v1:"." v2:__ { return token(v1, v2, c) }
COLON <- v1:":" v2:__ { return token(v1, v2, c) }
REGEQ <- v1:"=~" v2:_* { return token(v1, v2, c) }
REGNEQ <- v1:"!~" v2:__ { return token(v1, v2, c) }
STRINGEND <- v1:'"' v2:__ { return token(v1, v2, c) }
TRIPLESTRINGEND <- v1:"\"\"\"" v2:__ { return token(v1, v2, c) }

EOF <- !.